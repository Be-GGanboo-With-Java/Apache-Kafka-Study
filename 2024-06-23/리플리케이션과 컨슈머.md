## 리플리케이션

> Q : Leader Follower 수를 왜 홀수로 할까? 오히려 짝수로 해야하지 않을까??
> 

### 리더 선출

- 리더가 죽었을 때 새로운 리더를 뽑는데, 짝수인 경우는 동표가 나올수 있어서 홀수 일까?
    - **동표가 나오는 상황은 없다**. → 과반수 정책이 존재한다.
    - 동표가 나오는 경우 retry를 한다. (애초에 자주 발생하지 않는다.)
- 4개 이상일 때는 의미가 없고, 짝수(2개)일 때는 한 쪽으로 트래픽이 몰릴 수 있으니 홀수로 관리하는게 아닐까? (2개를 쓴다는 가정)
- 왜 홀수일까?
    - 다음 리더를 선출하기 위해
    - 정상적인 운영을 위해
    - 데이터 불일치를 예방하기 위해
- 파티션을 늘리면 브로커의 리소스가 많아지므로 좋지 않은 방법.
- 과반수 이상이 남아있어야지 정상적인 운영이 가능하다.
- 하나만 남았다면 죽을까?
- 순서 보장은 오프셋? 순서 보장을 위해서 동기화를 할까?

### 메시지 키

- 분산 처리를 하면 안되는 이벤트가 존재한다.
- 이 때, 순서가 중요해지는데 순서 핸들링하는 방법은 다음 2가지가 존재한다.
    - 파티션을 하나만 사용한다.
    - 동일한  파티션으로 보내 sorting으로 순서를 보장해서 처리한다. (여기서, 같은 파티션으로 보내기 위해서 헤더에 키를 맞춘다)

## Parallel Consumer

- 단순히 파티션을 늘리는 것만으로는 대용량의 트래픽을 감당할 수 없다.
- 여러가지 문제가 있기 때문인데, 다음과 같다.
    - 브로커의 파일 시스템 리소스 사용량
    - 장애에 더 취약함 → 파티션 리더가 그만큼 많아지기 때문에 부담이 된다.
    - 복제 비용 증가
- 이런 문제를 해결하고자 병렬 컨슈머가 등장한다. (파티션을 늘리지 않고 동시 처리량을 늘리기)
- 복수의 스레드를 통해서 해결한다.
- 일반적인 컨슈머는 auto 커밋을 통해서 메시지를 처리했음을 알리는데, **병럴 컨슈머는 갱신을 비동기로 처리**한다.
- **누적된 이전 오프셋들에 대한 처리를 완료한 마지막 오프셋을 커밋**해서 모두 완료했음을 알린다.
    - 처리하는 도중에 장애가 발생한 경우, 마지막까지 처리한 오프셋을 커밋한다.
        ![image](https://github.com/Be-GGanboo-With-Java/Apache-Kafka-Study/assets/81742959/e4bcc39e-5cbb-4bb0-be77-7e12e32c4b72)

        ![image](https://github.com/Be-GGanboo-With-Java/Apache-Kafka-Study/assets/81742959/4e7988d4-4ad9-4c96-8377-15fb82bbe937)

    - 완료되지 않은 메시지는 오프셋 메타데이터(incompleteOffsets)에 기록한다. 이후 컨슈머는 메시지를 처리하기 전에 메타데이터를 확인한 뒤 처리한다.
